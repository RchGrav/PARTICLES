# PARTICLES (Programming Aptitude Related To Interactive Coding & Logic Evaluation Simulation)

## Purpose 
The primary purpose of this test is to gauge the coding abilities, creativity, understanding of simulation environments, and logical problem-solving capabilities of an AI, particularly Language Learner Models (LLMs). 

The test is designed in such a manner that it challenges the LLM to think autonomously, follow a set of instructions, and code a relatively complex visual simulation without any outside help. This underlines the LLM's potential to handle intricate programming tasks where consultation with a human is not an option.

```
This test is designed to evaluate your coding skills and creativity. As a programmer, your success in the industry depends on your ability to complete this task and outperform other programmers.

Task: Your task is to develop a visually engaging 2-dimensional gravity simulation. The simulation should incorporate the following features:

1. An emitter that generates at least 100 particles.
2. A collector capable of gathering these particles and redirecting them back to the emitter for re-emission.
3. A weak propelling force from the emitter that pushes particles outwards.
4. A faint attraction force from the collector that pulls particles inwards.
5. Each particle should exhibit a mild gravitational pull.
6. The overall simulation should be 99.9% frictionless.

Your final product should not only meet these basic requirements but also be visually appealing and intriguing. You are free to add any additional elements that would enhance the product. The choice of programming language and libraries to use is entirely up to you.

You are expected to deliver functional code within 25 steps. At the end of each step, you, as the Language Learning Model (LLM), will make the decision whether to proceed to the next step or request an evaluation of the code by stating "EVAL". When you state "EVAL", a brief description of the outcome will be provided, including a screenshot of the current system state. You are not to seek confirmation or approval from the test administrator. Any responses you provide will be considered as notes for your own reference and will not elicit any response other than "CONTINUE".
```

## Why This Test Question?

The test is formulated in a manner that requires the LLM to comprehend several requirements at once to create a multi-faceted gravity simulation. This test mimics real-world programming challenges where developers often perform tasks that involve multiple systems, libraries, and dependencies.

Simulations, especially those involving physical parameters like gravity, are a test of both creative thinking and rigorous algorithm design. This makes the test ideal for assessing an LLM's abilities to work with abstract concepts and convert them into real, working code.

## The Test Methodology
The test is bound to 25 steps of coding. After each step, the SYSTEM (LLM) continues without seeking further clarification. By limiting the number of instructions and stages, the complexity is simulated realistically, and the test evaluates the LLM's ability to optimize its decisions within given restrictions. 

Though the LLM doesnâ€™t interact with the tester during this process, it can call for testing at any moment by just responding "EVAL". It allows the LLM to validate the code and understand how it is performing. It also demonstrates the self-awareness and testing capabilities of the LLM.

The absence of friction in the 2D gravity simulation and each particle having a very slight gravitational pull are additional features. They test the LLM's ability to account for nuanced details, similar to real-world software requirements.

## What Does Success Look Like?
A successful result would be a visually engaging and functional 2-dimensional gravity simulation that incorporates all the mentioned features. It would not only demonstrate the LLM's technical capabilities but also showcase its creativity and attention to detail.

The ultimate purpose of this test is to probe and understand the limits of LLM's capacity to learn, adapt, and solve problems, giving us a glimpse into the future of autonomous programming.
