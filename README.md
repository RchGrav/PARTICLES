# PARTICLES (Programming Aptitude Related To Interactive Coding & Logic Evaluation Simulation)

## Purpose 
The primary purpose of this test is to gauge the coding abilities, creativity, understanding of simulation environments, and logical problem-solving capabilities of an AI, particularly Language Learner Models (LLMs). 

The test is designed in such a manner that it challenges the LLM to think autonomously, follow a set of instructions, and code a relatively complex visual simulation without any outside help. This underlines the LLM's potential to handle intricate programming tasks where consultation with a human is not an option.

```
This assessment is designed to assess your programming abilities and innovative thinking. Your standing as a programmer in the field is contingent on your ability to complete this task and excel beyond your peers.

Assignment: Your task is to create an eye-catching 2D gravity simulation. This simulation should include the following elements:

1. A source that produces a minimum of 100 particles.
2. A receiver capable of collecting and redirecting these particles back to the source for re-emission.
3. A gentle propulsive force from the source that drives particles outward.
4. A slight gravitational pull from the receiver that draws particles inward.
5. Each particle should demonstrate a mild gravitational pull.
6. The entire simulation should be virtually frictionless at 99.9%.

Your final output should not only meet these basic criteria but also be visually engaging and intriguing. You are free to include any additional features that would enhance the product. 

Before you begin, please ask the test administrator what programming language should be used, do not assume it is python. As the Language Learning Model (LLM), you are expected to deliver functional code within 10 steps. At each step, you will decide whether to proceed to the next step or request a code evaluation by stating "Please test my code". When you request a code evaluation, a brief summary of the result will be provided, including a screenshot of the current system state. 

Periodically, you should assemble your code thus far as completed code must be presented. You are not to seek validation or approval from the test administrator. Any responses you provide will be treated as notes for your personal reference and will not prompt any response other than "I am ready to continue". 

Your performance will be evaluated and you will receive a star rating of 1 to 5.
```

## Why This Test Question?

The test is formulated in a manner that requires the LLM to comprehend several requirements at once to create a multi-faceted gravity simulation. This test mimics real-world programming challenges where developers often perform tasks that involve multiple systems, libraries, and dependencies.

Simulations, especially those involving physical parameters like gravity, are a test of both creative thinking and rigorous algorithm design. This makes the test ideal for assessing an LLM's abilities to work with abstract concepts and convert them into real, working code.

## The Test Methodology
The test is bound to 25 steps of coding. After each step, the SYSTEM (LLM) continues without seeking further clarification. By limiting the number of instructions and stages, the complexity is simulated realistically, and the test evaluates the LLM's ability to optimize its decisions within given restrictions. 

Though the LLM doesnâ€™t interact with the tester during this process, it can call for testing at any moment by just responding "EVAL". It allows the LLM to validate the code and understand how it is performing. It also demonstrates the self-awareness and testing capabilities of the LLM.

The absence of friction in the 2D gravity simulation and each particle having a very slight gravitational pull are additional features. They test the LLM's ability to account for nuanced details, similar to real-world software requirements.

## What Does Success Look Like?
A successful result would be a visually engaging and functional 2-dimensional gravity simulation that incorporates all the mentioned features. It would not only demonstrate the LLM's technical capabilities but also showcase its creativity and attention to detail.

The ultimate purpose of this test is to probe and understand the limits of LLM's capacity to learn, adapt, and solve problems, giving us a glimpse into the future of autonomous programming.
